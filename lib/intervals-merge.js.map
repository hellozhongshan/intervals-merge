{"version":3,"file":"intervals-merge.js","sources":["../src/index.js","../src/intervals-merge.js","../src/utils.js"],"sourcesContent":["import { merge } from './intervals-merge'\r\nimport { parseInterval } from './utils'\r\n\r\nlet development = '{{DEVELOPMENT}}' === 'development'\r\nif (development) {\r\n    console.log('开发模式  ')\r\n} else {\r\n    console.log('打包模式')\r\n}\r\n\r\nexport default {\r\n    version: '{{VERSION}}',\r\n    merge: (intervals = []) => merge(intervals.map(interval => parseInterval(interval)))\r\n}","export const merge = intervals => {\n  intervals.sort((a, b) => {\n    if (a.min !== b.min) {\n        return a.min - b.min;\n    }\n    if (a.max === b.max) {\n      if (a.rightOperator === ']' && b.rightOperator === ')') {\n        return true\n      } else {\n        return false\n      }\n    } else {\n      return a.max - b.max\n    }\n  })\n  const len = intervals.length\n  let ans = []\n  let leftOperator\n  let rightOperator\n  let start\n  let end\n\n  for (let i = 0; i < len; i++) {\n    let interval = intervals[i]\n    let s = interval.min\n    let  e = interval.max\n    if (start === undefined) {\n      start = s\n      end = e\n      leftOperator = interval.leftOperator\n      rightOperator = interval.rightOperator\n    } else if ((s === end && !(rightOperator === ')' && interval.leftOperator === '(')) || s < end) {\n      if (e === end) {\n        if (interval.rightOperator === ']' && rightOperator === ')') {\n          rightOperator = ']'\n        } else if (interval.rightOperator === ')' && rightOperator === ']') {\n          rightOperator = ']'\n        } else {\n          // TODO:\n          rightOperator = rightOperator\n        }\n        // TODO:\n        end = end\n      } else if (e > end) {\n        end = e\n        rightOperator = interval.rightOperator\n      } else {\n        // TODO:\n        end = end\n      }\n    } else {\n      let part = {\n        min: start,\n        max: end,\n        leftOperator,\n        rightOperator\n      }\n      ans.push(part)\n      start = s\n      end = e\n      leftOperator = interval.leftOperator\n      rightOperator = interval.rightOperator\n    }\n  }\n\n  if (start !== undefined) {\n    let part = {\n      min: start,\n      max: end,\n      leftOperator,\n      rightOperator\n    }\n    ans.push(part)\n  }\n\n  return ans\n}\n","export const parseInterval = interval => {\n  const intervalTemp = String(interval).slice(1, -1).replace(/∞/g, 'Infinity')\n  const inputRegexp = /(?:,|，)/g\n  const text = intervalTemp.split(inputRegexp)\n  const min = Number(text[0])\n  const max = Number(text[1])\n  const leftOperator = interval.substring(0, 1)\n  const rightOperator = interval.charAt(interval.length - 1)\n  return {\n    min,\n    max,\n    leftOperator,\n    rightOperator\n  }\n}\n"],"names":["log","sort","a","b","min","max","rightOperator","len","intervals","length","ans","leftOperator","start","end","i","interval","s","e","undefined","part","push","merge","map","text","String","slice","replace","split","Number","substring","charAt"],"mappings":"yMAOYA,IAAI,QAGD,SACF,cACF,kBCZU,cACTC,KAAK,SAACC,EAAGC,UACbD,EAAEE,MAAQD,EAAEC,IACLF,EAAEE,IAAMD,EAAEC,IAEjBF,EAAEG,MAAQF,EAAEE,IACU,MAApBH,EAAEI,eAA6C,MAApBH,EAAEG,cAM1BJ,EAAEG,IAAMF,EAAEE,cAGfE,EAAMC,EAAUC,OAClBC,EAAM,GACNC,SACAL,SACAM,SACAC,SAEKC,EAAI,EAAGA,EAAIP,EAAKO,IAAK,KACxBC,EAAWP,EAAUM,GACrBE,EAAID,EAASX,IACZa,EAAIF,EAASV,YACJa,IAAVN,IACMI,IACFC,IACSF,EAASJ,eACRI,EAAST,mBACpB,GAAKU,IAAMH,IAA2B,MAAlBP,GAAmD,MAA1BS,EAASJ,eAA0BK,EAAIH,EACrFI,IAAMJ,KACuB,MAA3BE,EAAST,eAA2C,MAAlBA,EACpB,IACoB,MAA3BS,EAAST,eAA2C,MAAlBA,EAC3B,IAGAA,IAGZO,GACOA,EAAJI,KACHA,IACUF,EAAST,iBAGnBO,MAEH,KACDM,EAAO,KACJP,MACAC,oCAIHO,KAAKD,KACDH,IACFC,IACSF,EAASJ,eACRI,EAAST,uBAIfY,IAAVN,EAAqB,KACnBO,EAAO,KACJP,MACAC,oCAIHO,KAAKD,UAGJT,ED/DsBW,yDAAP,IAAuBC,IAAI,qBAA0BP,EETrEQ,EAFeC,OAAOT,GAAUU,MAAM,GAAI,GAAGC,QAAQ,KAAM,YAEvCC,MADN,YAMb,KAJKC,OAAOL,EAAK,QACZK,OAAOL,EAAK,iBACHR,EAASc,UAAU,EAAG,iBACrBd,EAASe,OAAOf,EAASN,OAAS,IAP7B,MAGrBc"}